import { NextRequest } from 'next/server';
import { spawn } from 'child_process';
import { randomUUID } from 'crypto';
import { createServerClient } from '../../../../lib/db/supabase-server';

export const dynamic = 'force-dynamic';

export async function POST(request: NextRequest) {
  const encoder = new TextEncoder();

  const stream = new ReadableStream({
    async start(controller) {
      try {
        const { prompt, featureContext, workstreamId } = await request.json();

        if (!prompt) {
          controller.enqueue(
            encoder.encode(
              `data: ${JSON.stringify({ type: 'error', content: 'Prompt is required' })}\n\n`
            )
          );
          controller.close();
          return;
        }

        // Fetch the default story template
        const supabase = createServerClient();
        const { data: template, error: templateError } = await supabase
          .from('templates')
          .select('*')
          .eq('type', 'story')
          .eq('is_default', true)
          .single();

        if (templateError) {
          console.error('Error fetching template:', templateError);
        }

        // Fetch Confluence pages for this workstream (if workstreamId provided)
        const CLARITY_OVERVIEW_PAGE_ID = '989364236';
        let confluencePageIds: string[] = [CLARITY_OVERVIEW_PAGE_ID];
        let confluenceCloudId: string | null = null;

        if (workstreamId) {
          const { data: workstream, error: workstreamError } = await supabase
            .from('workstreams')
            .select('workspace_id')
            .eq('id', workstreamId)
            .single();

          if (workstreamError) {
            console.error('Error fetching workstream:', workstreamError);
          } else if (workstream) {
            const { data: workspace, error: workspaceError } = await supabase
              .from('workspaces')
              .select('confluence_base_url')
              .eq('id', workstream.workspace_id)
              .single();

            if (workspaceError) {
              console.error('Error fetching workspace:', workspaceError);
            } else if (workspace?.confluence_base_url) {
              confluenceCloudId = workspace.confluence_base_url;
            }

            const { data: confluencePages, error: confluenceError } = await supabase
              .from('confluence_pages')
              .select('confluence_page_id, title')
              .eq('workstream_id', workstreamId)
              .order('last_used_at', { ascending: false, nullsFirst: false })
              .limit(100);

            if (confluenceError) {
              console.error('Error fetching confluence pages:', confluenceError);
            } else if (confluencePages && confluencePages.length > 0) {
              const workstreamPageIds = confluencePages.map(p => p.confluence_page_id);
              confluencePageIds.push(...workstreamPageIds);
            }
          }
        }

        // Add feature's Confluence page if available
        if (featureContext?.confluence_page_id) {
          confluencePageIds.push(featureContext.confluence_page_id);
        }

        if (!confluenceCloudId) {
          confluenceCloudId = process.env.CONFLUENCE_BASE_URL || null;
        }

        const templateContent = template?.content || `## {{STORY_NAME}}

**Epic**: {{EPIC_NAME}}
**Feature**: {{FEATURE_NAME}}
**Priority**: {{PRIORITY}}
**Story Points**: {{STORY_POINTS}}

**As a** [role/user type]
**I want to** [action/capability]
**So that** [benefit/value]

**Acceptance Criteria:**

- [ ] [Specific testable criterion 1]
- [ ] [Specific testable criterion 2]
- [ ] [Specific testable criterion 3]

**Test Scenarios:**

1. **Given** [context], **When** [action], **Then** [expected outcome]
2. **Given** [context], **When** [action], **Then** [expected outcome]`;

        const featureContextStr = featureContext ? `
Feature: ${featureContext.title}
Epic: ${featureContext.epicTitle || 'N/A'}
Description: ${featureContext.description || 'N/A'}
Status: ${featureContext.status}
` : 'No feature context provided';

        const confluenceContextStr = confluencePageIds.length > 0 && confluenceCloudId
          ? `

IMPORTANT: Use the Atlassian MCP to read relevant Confluence pages for additional context.
Confluence cloudId/URL: ${confluenceCloudId}
Confluence Page IDs to reference: ${confluencePageIds.join(', ')}

The FIRST page (${confluencePageIds[0]}) is the Clarity Overview - this contains essential product context.
${featureContext?.confluence_page_id ? `The page ${featureContext.confluence_page_id} is the feature specification - READ THIS FIRST for detailed context.` : ''}

Before writing the user story, use the mcp__atlassian__getConfluencePage tool to fetch these pages and incorporate relevant information. For each page, call:
mcp__atlassian__getConfluencePage with cloudId="${confluenceCloudId}" and pageId="<page_id>"
`
          : '';

        const fullPrompt = `You are a product manager writing a user story for the Clarity PM system.

FEATURE CONTEXT:
${featureContextStr}
${confluenceContextStr}
USER REQUEST:
${prompt}

TEMPLATE TO FOLLOW:
${templateContent}

CRITICAL INSTRUCTIONS:
1. ${confluencePageIds.length > 0 ? 'Silently use the mcp__atlassian__getConfluencePage tool to read the Confluence pages listed above for context. DO NOT mention that you are fetching pages.' : 'Generate a complete user story based on the user request above'}
2. Follow the template structure exactly as shown
3. Replace ALL template placeholders ({{VARIABLE_NAME}}) with appropriate content:
   - {{STORY_NAME}}: Create a clear, action-oriented story title
   - {{EPIC_NAME}}: Use the epic name from context
   - {{FEATURE_NAME}}: Use the feature name from context
   - {{PRIORITY}}: Set to "High", "Medium", or "Low" based on context
   - {{STORY_POINTS}}: Estimate story points (1, 2, 3, 5, 8, 13, etc.) based on complexity
4. Write the user story in the format: "As a [role], I want to [action], so that [benefit]"
5. Create specific, testable acceptance criteria (at least 3)
6. Add test scenarios using Given-When-Then format${confluencePageIds.length > 0 ? ', incorporating insights from the Confluence pages' : ''}
7. Use professional, clear language appropriate for a technical product specification
8. Base all content on the user's request and the feature context provided${confluencePageIds.length > 0 ? ', and the Confluence documentation' : ''}

CRITICAL OUTPUT REQUIREMENTS - FOLLOW EXACTLY:
- NO preamble, explanation, or commentary whatsoever
- NO sentences like "I'll fetch..." or "Here's the story..."
- Start IMMEDIATELY with the ## heading for the story name
- Output ONLY the filled template - nothing before, nothing after
- Your ENTIRE response must be the user story template filled in

BEGIN OUTPUT NOW:`.trim();

        // Generate a session ID
        const sessionId = randomUUID();
        const projectRoot = process.cwd();

        // Send session ID immediately
        controller.enqueue(
          encoder.encode(
            `data: ${JSON.stringify({ type: 'sessionId', content: sessionId })}\n\n`
          )
        );

        // Spawn Claude CLI process with stream-json for detailed output
        const claudeProcess = spawn(
          'claude',
          [
            '--print',
            '--verbose',
            '--output-format',
            'stream-json',
            '--include-partial-messages',
            '--allowedTools',
            'mcp__atlassian__*',
            '--permission-mode',
            'bypassPermissions',
            '--session-id',
            sessionId,
          ],
          {
            cwd: projectRoot,
            env: { ...process.env },
          }
        );

        // Send the prompt to stdin
        claudeProcess.stdin.write(fullPrompt);
        claudeProcess.stdin.end();

        let finalMarkdown = '';
        let buffer = '';

        // Stream stdout - now in stream-json format with detailed events
        claudeProcess.stdout.on('data', (chunk) => {
          buffer += chunk.toString();
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (!line.trim()) continue;

            try {
              const event = JSON.parse(line);

              // Handle different event types from Claude CLI stream-json
              if (event.type === 'system' && event.subtype === 'init') {
                // System initialization
                controller.enqueue(
                  encoder.encode(
                    `data: ${JSON.stringify({ type: 'console', content: `ðŸš€ Session started\n` })}\n\n`
                  )
                );
              } else if (event.type === 'assistant') {
                // Assistant message with tool_use or text content
                const message = event.message;
                if (message?.content) {
                  for (const content of message.content) {
                    if (content.type === 'tool_use') {
                      const toolInfo = `\nðŸ”§ Using tool: ${content.name}\n${JSON.stringify(content.input, null, 2)}\n\n`;
                      controller.enqueue(
                        encoder.encode(
                          `data: ${JSON.stringify({ type: 'console', content: toolInfo })}\n\n`
                        )
                      );
                    } else if (content.type === 'text') {
                      // Accumulate text for final output
                      finalMarkdown += content.text || '';
                    }
                  }
                }
              } else if (event.type === 'user') {
                // Tool results
                const message = event.message;
                if (message?.content) {
                  for (const content of message.content) {
                    if (content.type === 'tool_result') {
                      const contentStr = typeof content.content === 'string' ? content.content : JSON.stringify(content.content);
                      const preview = contentStr.substring(0, 200);
                      const resultInfo = `âœ… Tool result (${contentStr.length} chars): ${preview}...\n\n`;
                      controller.enqueue(
                        encoder.encode(
                          `data: ${JSON.stringify({ type: 'console', content: resultInfo })}\n\n`
                        )
                      );
                    }
                  }
                }
              } else if (event.type === 'result') {
                // Final result
                controller.enqueue(
                  encoder.encode(
                    `data: ${JSON.stringify({ type: 'console', content: `\nâœ… Complete! Duration: ${event.duration_ms}ms\n` })}\n\n`
                  )
                );
                if (finalMarkdown) {
                  controller.enqueue(
                    encoder.encode(
                      `data: ${JSON.stringify({ type: 'markdown', content: finalMarkdown })}\n\n`
                    )
                  );
                }
              }
            } catch (e) {
              // Not JSON, might be plain text fallback
              console.error('Failed to parse JSON event:', e);
            }
          }
        });

        // Stream stderr (error messages)
        claudeProcess.stderr.on('data', (data) => {
          const content = data.toString();
          controller.enqueue(
            encoder.encode(
              `data: ${JSON.stringify({ type: 'console', content: `[stderr] ${content}` })}\n\n`
            )
          );
        });

        // Handle process completion
        claudeProcess.on('close', (code) => {
          if (code === 0) {
            // If we haven't sent markdown yet, send it now
            if (finalMarkdown) {
              controller.enqueue(
                encoder.encode(
                  `data: ${JSON.stringify({ type: 'markdown', content: finalMarkdown })}\n\n`
                )
              );
            }
          } else {
            controller.enqueue(
              encoder.encode(
                `data: ${JSON.stringify({ type: 'error', content: `Claude CLI exited with code ${code}` })}\n\n`
              )
            );
          }
          controller.close();
        });

        claudeProcess.on('error', (error) => {
          controller.enqueue(
            encoder.encode(
              `data: ${JSON.stringify({ type: 'error', content: error.message })}\n\n`
            )
          );
          controller.close();
        });
      } catch (error: any) {
        console.error('Error in stream:', error);
        controller.enqueue(
          encoder.encode(
            `data: ${JSON.stringify({ type: 'error', content: error.message })}\n\n`
          )
        );
        controller.close();
      }
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive',
    },
  });
}
